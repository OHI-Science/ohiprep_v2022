---
title: "sb_extent_explore"
output: html_document
date: '2022-08-31'
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(terra)
library(tidyverse)
source('http://ohi-science.org/ohiprep_v2022/workflow/R/common.R')
#library(raster)
```

Pull in all files that represent soft bottom habitat extent (Halpern et al. 2015):

1. habitat_d_s_benthic
2. habitat_s_t_s_bottom
3. habitat_soft_shelf
4. habitat_soft_slope
5. habitat_inttidalmud

```{r}
# create raster stack of all 5 tif files that represent different types of soft bottom habitat
sb_hab_raw_stack <- rast(list.files(paste0(dir_M, "/git-annex/globalprep/hab_prs_hd_subtidal_soft_bottom/v2022/int/soft_bottom_extent/tifs/"), pattern = ".tif", full = TRUE))

# check metadata
sb_hab_raw_stack

# get an idea what one layer looks like to make sure summation works
plot(sb_hab_raw_stack[[5]], col = "red")
sb_hab_raw_stack[[5]]

# sum all rasters to create composite raster for all soft bottom habitat
sb_hab_composite <- terra::app(sb_hab_raw_stack, fun = "sum", na.rm = TRUE)

# convert all values great than 1 to 1, so we have a presence/absence raster for all soft bottom habitat. Values greater than one represent cells that have been assigned to 2 different soft bottom habitat types, but this is not helpful for our purposes.
sb_hab_composite[sb_hab_composite >= 1] <- 1

plot(sb_hab_composite, col = "red")
```

Pull in fishing effort rasters for each year, so we can process each and multiply them by the soft bottom habitat extent.

```{r}
fish_effort <- list.files(paste0(dir_M, "/git-annex/globalprep/hab_prs_hd_subtidal_soft_bottom/v2022/final_rasters"), pattern = ".tif", full = TRUE)

# 2020
fish_effort[9]

# rasterize file
fish_effort_2020 <- rast(fish_effort[9])
fish_effort_2020

# rasterize each file
# for (i in fish_effort) {
#   raster <- rast(fish_effort[i])
#   
# }

# fish_effort[is.na(fish_effort)] <- 0

#plot(cellSize(fish_effort_2020, unit = "km"))
```

Convert the soft bottom habitat raster (resolution units = meters, CRS = WGS_1984_Mollweide) to a coarser resolution because we know that there is error associated with our soft bottom habitat measurements. Aggregating allows us to make a buffer around each cell, which helps account for this uncertainty.

```{r}
# the soft bottom habitat layer is higher resolution than the fishing effort raster, so we aggregate it 
sb_hab_coarse <- terra::aggregate(x = sb_hab_composite, fact = 5, fun = "sum", na.rm = TRUE) 
sb_hab_coarse
# 4672.394 x 4672.394 meters resolution
```

The goal of this raster is to multiply it by the fishing effort raster to identify the proportion of the fishing effort per cell that affected soft bottom habitat, so we need each cell of the soft bottom habitat raster to represent the **proportion** of that area that is soft bottom. To convert the cell value to a proportion, we divide by the number of original cells that were aggregated into each derived cell.

```{r}
# min value of raster: 1
# max value of raster: 25
# since we aggregated by a factor of 5 and used the sum function, each cell now represents the sum of the cells within a square of 25 cells. If all those cells represented soft bottom habitat, meaning they all had a value of 1, then the value of those cells is now 25
sb_hab_prop <- sb_hab_coarse/25
```

Aggregate the fishing effort raster, too, because we know there is also similar error associated with the fishing effort data and because we want the resolutions of the two rasters to be similar.

- The resolution of the **fishing effort** raster is **0.01 x 0.01 degrees**, CRS = lon/lat WGS 84 (EPSG:4326). 
- The resolution of the **soft bottom habitat** raster is **~934 x 934 meters**, CRS = WGS_1984_Mollweide.

We know that the soft bottom habitat raster has a very similar resolution because ~934 x ~934 meters translates to ~0.934 square kilometers, and 0.01 x 0.01 degrees translates to ~1.11 square kilometers at the equator (the exact size of the degree cells differs slightly based on the latitude of the raster cell). So since the resolutions are similar to start, we want to aggregate them similarly as well. 

```{r}
fish_effort_2020_coarse <- terra::aggregate(x = fish_effort_2020, fact = 5, fun = "sum", na.rm = TRUE) # unequal area, but equal angle
# 0.05 x 0.05 resolution 

#global(fish_effort, "sum", na.rm = TRUE)
#global(fish_effort_coarse, "sum", na.rm = TRUE) # 18379444
```
The fishing effort raster is in units of pure fishing hours, so it is not already standardized over the area of each cell. This raster is **equal angle** and not **equal area**, as the soft bottom habitat raster is, meaning that the cell values differ based on latitude. As such, we should divide the fishing hours for each cell by the area of the cell, which we calculate with `terra::cellSize(unit = "km")` so that the division is based on the actual size of each individual cell. This standardization is necessary because we need to reproject the fishing effort raster into the same CRS as the soft bottom habitat raster, which changes the projection of the fishing hours over space, and we do not want to change the total value of fishing hours for each year. To avoid that, we do the following:

1. Convert the units of fishing hours to fishing hours per kilometer
2. Reproject the CRS of the soft bottom habitat raster
3. Multiply the fishing hours raster cells by the size of the **newly aggregated equal area raster**

This approach is not perfect because there will still be a slight discrepancy between the sum of the fishing hours before and after reprojecting, but this does a relatively clean job of retaining the correct hours per area. Lastly, we multiply the raster of soft bottom habitat proportion by the fishing effort raster to subset the fishing hours to those that only affect soft bottom habitat.

```{r}
fish_effort_2020_hr_km <- fish_effort_2020_coarse/cellSize(fish_effort_2020_coarse, unit = "km")

fish_effort_2020_reproj <- project(fish_effort_2020_hr_km, sb_hab_prop)

fish_effort_2020_reproj_fix <- fish_effort_2020_reproj*21.83127

#global(fish_effort_reproj_fix, "sum", na.rm = TRUE) # 18541882, very close to what it was before reprojecting

multiply <- fish_effort_2020_reproj_fix*sb_hab_prop # units of hours * proportion of that cell which is sb hab, resulting units are hrs of fishing effort 

# compare the raw fishing effort raster and the multiply raster, to check that that multiply raster is a subset of the fishing effort raster
#plot(fish_effort, col = "red")
```

Now that we multiplied the rasters, we should consider the difference between `NA` values and 0 values. The `NA` values in this raster represent cells that either did not have fishing effort, do not contain soft bottom habitat, or both, so they should be converted to 0 to represent no soft bottom habitat destruction.

```{r}
multiply[is.na(multiply)] = 0 
```

Switching gears a bit, we now want to correct the aggregated soft bottom habitat raster to cap the values of each cell at 1. This yields a raster that represents whether or not soft bottom habitat is present in a cell at all, rather than the amount of soft bottom habitat standardized over the area of the cells, which is represented in the raster we made earlier, `sb_hab_prop`.

```{r}
# first check if there are values in the aggregated raster that are between 0 and 1
values <- terra::unique(sb_hab_coarse)
# whole numbers ranging from 1-25, and NA

# duplicate object with another name
sb_hab_coarse_fix <- sb_hab_coarse  

# cap values at 1 to convert this raster into a presence(1) or absence(0) raster
sb_hab_coarse_fix[sb_hab_coarse_fix >= 1] <- 1
```

Apply a mask to the raster that represents just the trawling and dredging fishing effort standardized over the amount of soft bottom habitat, so we can retain the soft bottom habitat that is undisturbed in addition to the woft bottom habitat that is disturbed (which is already present in `multiply`).

**Juliet's question**: based on the documentation for mask() and my undersatnding of spatial masking, I would think that this step only retains fishing effort that falls on cells with soft bottom habitat. However, I know that we already multiplied the rasters earlier, and multiplying na by a number yields na, so i think that is already the case. It makes sense why we retain sb habitat that is not disturbed, but I want to convince myself that this is what this function is doing. 

```{r}
# the raster `multiply` has no NA values
# the raster `sb_hab_coarse_fix` has values either 1 or NA
multiply_mask <- mask(x = multiply, mask = sb_hab_coarse_fix) 
# now the raster `multiply_mask` does contain NA values where there is no soft bottom habitat at all
# we want to add in the soft bottom habitat that is undisturbed because we need to be able to assign regions that are not disturbing available soft bottom habitat with a good score

plot(multiply_mask)
# multiply_mask[multiply_mask == 0] <- 10000000000 # test

#plot(log(multiply_mask+1))
#plot(multiply_mask)
#zoom(multiply_mask)
#click(multiply_mask)

## mask by converted sb_hab_coarse to keep healthy SB habitats 
## rescale these rasters by 99.9 or something (0-1); THIS IS THE PRESSURE
## then extract by OHI region 
##TO GET HEALTH: 1 - PRESSURE from above step

```

```{r}
plot(sb_hab_coarse, col = "red")
```
















Change crs to mollewide 

```{r}
#mollCRS <- CRS("+proj=moll")
#fish_effort_mol <- terra::project(fish_effort, mollCRS)
```

Make extents match

```{r}
#compareGeom(sb_hab_raw, fish_effort)

#ext(sb_hab_raw)
#ext(fish_effort)

```

```{r}
#fish_effort_extended <- terra::extend(fish_effort, sb_hab_raw)
#ext(fish_effort_extended)

#sb_raw_extended
```

Compare the extents of the rasters.

```{r}
# sb_extent <- ext(sb_hab_raw) # -18040095.1961317, 18040134.2452714, -9020047.34806998, 9020067.3726316 (xmin, xmax, ymin, ymax)
# fish_extent <- ext(fish_effort) # -180.005, 180.005, -67.315, 81.985 (xmin, xmax, ymin, ymax)
# 
# # plot extents to better understand why the numerical extents are different for 2 global rasters
# sb_extent_polygon <- terra::as.polygons(sb_extent)
# fish_extent_polygon <- terra::as.polygons(fish_extent)
# 
# terra::crs(sb_extent_polygon) <- "epsg:4326" # this can be used to assign a crs if there was no crs to begin with 
# 
# ggplot(data = world) +
#   geom_sf() +
#   tidyterra::geom_spatvector(data = extent_polygon, color = "Red", fill = NA)
```

