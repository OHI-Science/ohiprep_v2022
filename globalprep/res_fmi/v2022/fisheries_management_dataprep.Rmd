---
title: "gov_gdp_model"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(tidyverse)
library(readxl)
library(janitor)
library(ohicore)
library(here)
library(plotly)
library(psych) # for correlation testing
source('https://raw.githubusercontent.com/OHI-Science/ohiprep_v2019/gh-pages/workflow/R/common.R')

version_year = "2022"
# most recent data for 2022 scenario year is 2019, Minderoo will update governance data again in 2024
recent_data_yr <- 2019
```

```{r}
# governance variables
gov_data <- read_excel(here("globalprep/res_fmi/v2022/raw/Global_Fishing_Index_2021_Data_for_Download_V1.1.xlsx"), sheet = 3, col_names = FALSE) %>% 
  row_to_names(row_number = 1) %>%
  row_to_names(row_number = 1) %>% 
  clean_names() %>% 
  # add year 2019 to every row since this data was all from 2019 (and some from the start of 2020, but the metadata does not clairfy which ovsrevations are from which year so we will assume all are 2019)
  mutate(year = c("2019"))

gov_data$year <- as.numeric(gov_data$year)

# load variable descriptions
gov_key <- read_excel(here("globalprep/res_fmi/v2022/raw/Global_Fishing_Index_2021_Data_for_Download_V1.1.xlsx"), sheet = 2)    
```

### Add OHI regions to gov data

```{r}
# first clean a few country names 
# duplicate "Bonaire, Sint Eustatius and Saba": split into 3 rows each with the same data
caribbean_split <- gov_data %>% 
  filter(country == "Bonaire, Sint Eustatius and Saba") %>% 
  tidyr::separate_rows(country, sep = ", ") %>% 
  tidyr::separate_rows(country, sep = " and ")

# ## Split "Kiribati" into "Line Islands (Kiribati)", "Phoenix Islands (Kiribati)", & "Gilbert Islands (Kiribati)"
# kiribati_split <- gov_data %>%
#   dplyr::filter(country == "Kiribati") %>%
#   dplyr::mutate(country = stringr::str_replace_all(
#       string = country, 
#       pattern = "Kiribati", 
#       replacement = "Line Islands (Kiribati), Phoenix Islands (Kiribati), Gilbert Islands (Kiribati)")) %>%
#   tidyr::separate_rows(country, sep = ", ") 

# must separate Taiwan from "(province of China) in this way because gsub() and str_repalce_all() do not to the trick for this one:
taiwan_split <- gov_data %>% 
  filter(country == "Taiwan (Province of China)") %>% 
  tidyr::separate_rows(country, sep = " ") %>% 
  filter(country == "Taiwan")

gov_data <- rbind(gov_data, caribbean_split) %>%
  #rbind(kiribati_split) %>%
  rbind(taiwan_split) %>% 
  filter(!country %in% c("Bonaire, Sint Eustatius and Saba", "Taiwan (Province of China)"))

gov_data$country <- gsub(pattern = "Côte d’Ivoire", replacement = "Ivory Coast", x = gov_data$country)
gov_data$country <- gsub("Federated States of Micronesia", "Micronesia", gov_data$country)
gov_data$country <- gsub("Islamic Republic of Iran", "Iran", gov_data$country)
gov_data$country <- gsub("Turks and Caicos Island", "Turks and Caicos Islands", gov_data$country)

gov_data <- gov_data %>% 
  name_2_rgn(fld_name = 'country',
             flds_unique = c('rgn_id', 'rgn_name'))
```

### Rescale government capacity data to range 0-1

```{r}
gov_data$governance_capacity <- as.numeric(gov_data$governance_capacity)
# rescale the governance capacity values between 0-1
# normalized = (x-min(x))/(max(x)-min(x)) (https://www.statology.org/normalize-data-between-0-and-1/)
gov_data <- gov_data %>% 
  mutate(gov_capacity = (governance_capacity - min(governance_capacity))/(max(governance_capacity) - min(governance_capacity)))

gov_data <- gov_data %>% select(rgn_id, rgn_name, gov_capacity, year)
```

## Create initial model for gapfilling using just GDP data

```{r}
# read in rescaled GDP data (values range between 0-1 and capped at 95th quantile)
gdp <- read.csv(here("globalprep/ao/v2022/output/wb_gdppcppp_rescaled.csv"))

# join government capacity data to GDP data
gov_gdp <- gov_data %>% 
  left_join(gdp, by = c("rgn_id", "year")) %>% 
  rename(gdp = value)

# regress gov & gdp without georegion labels (yet)
gov_gdp_mod <- lm(gov_capacity ~ gdp, data = gov_gdp)
summary(gov_gdp_mod)
# adj r2: 0.08755

# Look at correlation
ggplotly(ggplot(gov_gdp, aes(x = gdp, y = gov_capacity, labels = rgn_name)) +
  geom_point() +
  geom_abline(slope = 1, intercept = 0, color = "red"))
```

```{r}
# calculate pearson's correlation
gov_gdp_plot <- gov_gdp %>% 
  select(gdp, gov_capacity)

pairs.panels(gov_gdp_plot, density = TRUE, cor=TRUE, lm=TRUE)

# try logging gdp (it has already been rescaled..not sure if thats good science?)
# gov_gdp_plot_test <- gov_gdp_plot %>% 
#   mutate(log_gdp = log(gdp)) %>% 
#   select(log_gdp, normalized_gov_capacity)
# 
# pairs.panels(gov_gdp_plot_test, density = TRUE, cor=TRUE, lm=TRUE)
```

## Create better models for gapfilling using GDP and UN regions (r2 lables)

```{r}
# Load UN georegion data 
georegions <- UNgeorgn() %>%
  select(rgn_id, rgn_name = rgn_label, r1_label, r2_label)

gov_gdp_georegions <- gov_gdp %>%
  left_join(georegions, by = c("rgn_id","rgn_name")) %>%
  select(rgn_id, rgn_name, gov_capacity, gdp, r2_label, r1_label, year)

# return rows that contain NA in any column
gov_gdp_georegions[rowSums(is.na(gov_gdp_georegions)) > 0, ] # Kiribati has NA for r2_label & r1_label because in UNgeoregion(), Kiriati is split into Line Islands (Kiribati), Phoenix Islands (Kiribati), and Gilbert Islands (Kiribati), but Kiribati is the correct OHI region name

# fill Kiribati row with correct r1_label and r2_label (extracted from island subsets labels)
gov_gdp_georegions <- gov_gdp_georegions %>%
  mutate(r2_label = ifelse(is.na(r2_label), "Micronesia", r2_label)) %>%
  mutate(r1_label = ifelse(is.na(r1_label), "Oceania", r1_label))

# regress gov & gdp with r2 georegion lables - that was the highest r2 of all models tried
gov_gdp_r2_mod <- lm(gov_capacity ~ gdp + r2_label, data = gov_gdp_georegions)
summary(gov_gdp_r2_mod)
# adj r2: 0.4128

# regress gov & gdp with r1 georegion lables
gov_gdp_r1_mod <- lm(gov_capacity ~ gdp + r1_label, data = gov_gdp_georegions)
summary(gov_gdp_r1_mod)
# adj r2: 0.2043
```

## Make predictions with this gdp + r2_label model and compare to observed

```{r}
# Create array of predicted progress score values 
gov_gdp_r2_pred <- gov_gdp_georegions %>%
  dplyr::group_by(rgn_id) %>%
  dplyr::do({ 
    gov_r2_pred <- predict(gov_gdp_r2_mod, newdata =.[c('r2_label', 'gdp')]) 
    data.frame(., gov_r2_pred) # do() loop applies the model fitting and prediction to each country group
  }) %>% 
  dplyr::ungroup()

# Plot predicted vs actual values 
ggplotly(ggplot(gov_gdp_r2_pred, aes(x = gov_capacity, y = gov_r2_pred, labels = rgn_name)) +
  geom_point() +
  geom_abline(slope = 1, intercept = 0, color = "red") +
  labs(x = "Observed Government Capacity",
      y = "Predicted Government Capacity",
      title = "Observed vs Predicted Government Capacity: GDP + r2 georegions model"))
```

## Make predictions with this gdp + r1_label model and compare to observed

```{r}
# Create array of predicted progress score values 
gov_gdp_r1_pred <- gov_gdp_georegions %>%
  dplyr::group_by(rgn_id) %>%
  dplyr::do({ 
    gov_r1_pred <- predict(gov_gdp_r1_mod, newdata =.[c('r1_label', 'gdp')]) 
    data.frame(., gov_r1_pred) # do() loop applies the model fitting and prediction to each country group
  }) %>% 
  dplyr::ungroup()

# Plot predicted vs actual values 
ggplotly(ggplot(gov_gdp_r1_pred, aes(x = gov_capacity, y = gov_r1_pred, labels = rgn_name)) +
  geom_point() +
  geom_abline(slope = 1, intercept = 0, color = "red") +
  labs(x = "Observed Government Capacity",
      y = "Predicted Government Capacity",
      title = "Observed vs Predicted Government Capacity: GDP + r1 georegions model"))
```

## Gapfill GDP data for all 220 OHI regions before using GDP data to gapfill for government capacity

```{r}
gdp_geo_2019 <- UNgeorgn %>%
  # Reunion is a part of the French Republic
  mutate(rgn_label = ifelse(str_detect(rgn_label, "R_union"), "Reunion", rgn_label)) %>%
  rename(rgn_name = rgn_label) %>%
  left_join(gdp, by = "rgn_id") %>% 
  rename(gdp = value) %>% 
  filter(year == 2019) 

gdp_geo_2019$gdp[is.nan(gdp_geo_2019$gdp)]

na_georegions <- gdp_gapfill_2019[rowSums(is.na(gdp_geo_2019)) > 0, ] %>% 
  group_by(r2_label) %>% 
  summarize(count = n())

# gapfill these 20 countries that are missing 2019 data with other countries within r2_label from 2019
gdp_2019_mean <- gdp_geo_2019 %>% 
  group_by(r2_label) %>%
  summarize(mean_gdp = mean(gdp, na.rm = TRUE))
# it's ok that the southern islands mean value is NaN because ALL the GDP values for those regions are deliberately set to NA because their population is less than 3000


```

## Gapfill

```{r}
# rejoin georegions, gov_data, & gdp from scratch so we can get GDP numbers for countries regardless if they were present in gov_data
gov_gf <- UNgeorgn %>%
  # Reunion is a part of the French Republic
  mutate(rgn_label = ifelse(str_detect(rgn_label, "R_union"), "Reunion", rgn_label)) %>%
  rename(rgn_name = rgn_label) %>%
  left_join(gdp, by = "rgn_id") %>% # need to join GDP before gov_data because GDP contains more OHI regions that gov_data
  rename(gdp = value) %>%
  left_join(gov_data, by = c("rgn_id", "rgn_name", "year")) %>%
  filter(year == recent_data_yr) %>% 
  select(-c(rgn_name, r0_label, year)) 

# check if there are any r2 labels that only occur once
table(UNgeorgn$r2_label)
sum(is.na(gov_gf$gdp))







# create predictions with the model in a more complicated fashion because some r2 categories may have no data, this returns an NA for these
# sapply() creates an array object, we need an array rather than a list object (which would be the output of lapply())
gov_gf$gov_pred_r2 <- sapply(1:nrow(gov_gf),
                             function(i) # use all columns in that row to feed into the model to generate a gov_capacity prediction
                               tryCatch(predict(gov_gdp_r2_mod, gov_gf[i,]), error = function(e) NA)) 

# fill in predictions for the regions not represented by r2 regions:
gov_gf$gov_pred_r1 <-
  sapply(1:nrow(gov_gf), 
         function(i) 
           tryCatch(predict(gov_gdp_r1_mod, gov_gf[i,]), error = function(e) NA))

# final data and gapfilling recordkeeping
gov_gf_all <- gov_gf %>%
  # if there is no existing value for gov_capacity, put a 1 to identify that it is gapfilled:
  dplyr::mutate(gapfilled = ifelse(is.na(gov_capacity), "1", 0)) %>%
  # if there is no existing value for gov_capacity & there is a prediction from the model using GDP & r2_label, use that model for the gapfill method: 
  dplyr::mutate(method = ifelse(is.na(gov_capacity) & !is.na(gov_pred_r2), "SPI + UN_geopolitical region r2", NA)) %>%
  # if there is no existing value for gov_capacity & no prediction from the model using GDP and r1_label, use the GDP & r1_label for the gapfill method:
  dplyr::mutate(method = ifelse(is.na(gov_capacity) & is.na(gov_pred_r2), "SPI + UN_geopolitical region r1" , method)) %>%
  dplyr::mutate(gov_capacity = ifelse(is.na(gov_capacity), gov_pred_r2, gov_capacity)) %>% 
  dplyr::mutate(gov_capacity = ifelse(is.na(gov_capacity), gov_pred_r1, gov_capacity))

# make sure all low/no population regions are NA 
low_pop()
low_pop <- low_pop %>%
  filter(est_population < 3000 | is.na(est_population)) #filter out regions that have populations > 3000 and keep NA values 

fmi_gf_low_pop <- fmi_gf_all %>%
  dplyr::filter(rgn_id %in% low_pop$rgn_id)
summary(fmi_gf_low_pop)
  

## Make sure all other regions have an fmi value
fmi_gf_with_pop <- fmi_gf_all %>%
  dplyr::filter(!(rgn_id %in% low_pop$rgn_id))
summary(fmi_gf_with_pop)


# Correct gapfilling info to low pop regions
fmi_gf_all <- fmi_gf_all %>% 
  mutate(gapfilled = ifelse(rgn_id %in% low_pop$rgn_id, 0, gapfilled)) %>% 
  mutate(method = ifelse(rgn_id %in% low_pop$rgn_id, NA, method))

## format final data
fmi_final <- fmi_gf_all %>%
  select(rgn_id, year, value=fmi)
dim(fmi_final) # all regions represented
summary(fmi_final) # 20 NA values


# Save the data 
write_csv(fmi_final, here("globalprep/res_fmi/v2019/output/fmi_res.csv"))


# Save dataframe with gapfilled method and status information
final_fmi_gf <- fmi_gf_all %>%
  select(rgn_id, year, gapfilled, method)
write_csv(final_fmi_gf, here("globalprep/res_fmi/v2019/output/fmi_res_gf.csv"))


```














